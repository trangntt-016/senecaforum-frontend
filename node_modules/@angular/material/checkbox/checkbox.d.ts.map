{"version":3,"file":"checkbox.d.ts","sources":["checkbox.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { FocusableOption, FocusMonitor, FocusOrigin } from '@angular/cdk/a11y';\r\nimport { BooleanInput, NumberInput } from '@angular/cdk/coercion';\r\nimport { AfterViewChecked, ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnDestroy, AfterViewInit } from '@angular/core';\r\nimport { ControlValueAccessor } from '@angular/forms';\r\nimport { CanColor, CanColorCtor, CanDisable, CanDisableCtor, CanDisableRipple, CanDisableRippleCtor, HasTabIndex, HasTabIndexCtor, MatRipple } from '@angular/material/core';\r\nimport { MatCheckboxDefaultOptions } from './checkbox-config';\r\n/**\r\n * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.\r\n * This allows it to support [(ngModel)].\r\n * @docs-private\r\n */\r\nexport declare const MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR: any;\r\n/**\r\n * Represents the different states that require custom transitions between them.\r\n * @docs-private\r\n */\r\nexport declare const enum TransitionCheckState {\r\n    /** The initial state of the component before any user interaction. */\r\n    Init = 0,\r\n    /** The state representing the component when it's becoming checked. */\r\n    Checked = 1,\r\n    /** The state representing the component when it's becoming unchecked. */\r\n    Unchecked = 2,\r\n    /** The state representing the component when it's becoming indeterminate. */\r\n    Indeterminate = 3\r\n}\r\n/** Change event object emitted by MatCheckbox. */\r\nexport declare class MatCheckboxChange {\r\n    /** The source MatCheckbox of the event. */\r\n    source: MatCheckbox;\r\n    /** The new `checked` value of the checkbox. */\r\n    checked: boolean;\r\n}\r\n/** @docs-private */\r\ndeclare class MatCheckboxBase {\r\n    _elementRef: ElementRef;\r\n    constructor(_elementRef: ElementRef);\r\n}\r\ndeclare const _MatCheckboxMixinBase: HasTabIndexCtor & CanColorCtor & CanDisableRippleCtor & CanDisableCtor & typeof MatCheckboxBase;\r\n/**\r\n * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,\r\n * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or\r\n * disabled. Note that all additional accessibility attributes are taken care of by the component,\r\n * so there is no need to provide them yourself. However, if you want to omit a label and still\r\n * have the checkbox be accessible, you may supply an [aria-label] input.\r\n * See: https://material.io/design/components/selection-controls.html\r\n */\r\nexport declare class MatCheckbox extends _MatCheckboxMixinBase implements ControlValueAccessor, AfterViewInit, AfterViewChecked, OnDestroy, CanColor, CanDisable, HasTabIndex, CanDisableRipple, FocusableOption {\r\n    private _changeDetectorRef;\r\n    private _focusMonitor;\r\n    private _ngZone;\r\n    _animationMode?: string | undefined;\r\n    private _options?;\r\n    /**\r\n     * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will\r\n     * take precedence so this may be omitted.\r\n     */\r\n    ariaLabel: string;\r\n    /**\r\n     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\r\n     */\r\n    ariaLabelledby: string | null;\r\n    /** The 'aria-describedby' attribute is read after the element's label and field type. */\r\n    ariaDescribedby: string;\r\n    private _uniqueId;\r\n    /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */\r\n    id: string;\r\n    /** Returns the unique id for the visual hidden input. */\r\n    get inputId(): string;\r\n    /** Whether the checkbox is required. */\r\n    get required(): boolean;\r\n    set required(value: boolean);\r\n    private _required;\r\n    /** Whether the label should appear after or before the checkbox. Defaults to 'after' */\r\n    labelPosition: 'before' | 'after';\r\n    /** Name value will be applied to the input element if present */\r\n    name: string | null;\r\n    /** Event emitted when the checkbox's `checked` value changes. */\r\n    readonly change: EventEmitter<MatCheckboxChange>;\r\n    /** Event emitted when the checkbox's `indeterminate` value changes. */\r\n    readonly indeterminateChange: EventEmitter<boolean>;\r\n    /** The value attribute of the native input element */\r\n    value: string;\r\n    /** The native `<input type=\"checkbox\">` element */\r\n    _inputElement: ElementRef<HTMLInputElement>;\r\n    /** Reference to the ripple instance of the checkbox. */\r\n    ripple: MatRipple;\r\n    /**\r\n     * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\r\n     * @docs-private\r\n     */\r\n    _onTouched: () => any;\r\n    private _currentAnimationClass;\r\n    private _currentCheckState;\r\n    private _controlValueAccessorChangeFn;\r\n    constructor(elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, _focusMonitor: FocusMonitor, _ngZone: NgZone, tabIndex: string, _animationMode?: string | undefined, _options?: MatCheckboxDefaultOptions | undefined);\r\n    ngAfterViewInit(): void;\r\n    ngAfterViewChecked(): void;\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * Whether the checkbox is checked.\r\n     */\r\n    get checked(): boolean;\r\n    set checked(value: boolean);\r\n    private _checked;\r\n    /**\r\n     * Whether the checkbox is disabled. This fully overrides the implementation provided by\r\n     * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.\r\n     */\r\n    get disabled(): any;\r\n    set disabled(value: any);\r\n    private _disabled;\r\n    /**\r\n     * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\r\n     * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\r\n     * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\r\n     * set to false.\r\n     */\r\n    get indeterminate(): boolean;\r\n    set indeterminate(value: boolean);\r\n    private _indeterminate;\r\n    _isRippleDisabled(): any;\r\n    /** Method being called whenever the label text changes. */\r\n    _onLabelTextChange(): void;\r\n    writeValue(value: any): void;\r\n    registerOnChange(fn: (value: any) => void): void;\r\n    registerOnTouched(fn: any): void;\r\n    setDisabledState(isDisabled: boolean): void;\r\n    _getAriaChecked(): 'true' | 'false' | 'mixed';\r\n    private _transitionCheckState;\r\n    private _emitChangeEvent;\r\n    /** Toggles the `checked` state of the checkbox. */\r\n    toggle(): void;\r\n    /**\r\n     * Event handler for checkbox input element.\r\n     * Toggles checked state if element is not disabled.\r\n     * Do not toggle on (change) event since IE doesn't fire change event when\r\n     *   indeterminate checkbox is clicked.\r\n     * @param event\r\n     */\r\n    _onInputClick(event: Event): void;\r\n    /** Focuses the checkbox. */\r\n    focus(origin?: FocusOrigin, options?: FocusOptions): void;\r\n    _onInteractionEvent(event: Event): void;\r\n    private _getAnimationClassForCheckStateTransition;\r\n    /**\r\n     * Syncs the indeterminate value with the checkbox DOM node.\r\n     *\r\n     * We sync `indeterminate` directly on the DOM node, because in Ivy the check for whether a\r\n     * property is supported on an element boils down to `if (propName in element)`. Domino's\r\n     * HTMLInputElement doesn't have an `indeterminate` property so Ivy will warn during\r\n     * server-side rendering.\r\n     */\r\n    private _syncIndeterminate;\r\n    static ngAcceptInputType_disabled: BooleanInput;\r\n    static ngAcceptInputType_required: BooleanInput;\r\n    static ngAcceptInputType_disableRipple: BooleanInput;\r\n    static ngAcceptInputType_indeterminate: BooleanInput;\r\n    static ngAcceptInputType_tabIndex: NumberInput;\r\n}\r\nexport {};\r\n"]}