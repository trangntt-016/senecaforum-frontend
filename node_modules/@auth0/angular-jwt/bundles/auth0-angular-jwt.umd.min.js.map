{"version":3,"sources":["../../../projects/angular-jwt/src/lib/jwtoptions.token.ts","../../../projects/angular-jwt/src/lib/jwthelper.service.ts","../../../projects/angular-jwt/src/lib/jwt.interceptor.ts","../../../projects/angular-jwt/src/lib/angular-jwt.module.ts"],"names":["JWT_OPTIONS","InjectionToken","JwtHelperService","config","this","tokenGetter","prototype","urlBase64Decode","str","output","replace","length","Error","b64DecodeUnicode","b64decode","String","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","decodeURIComponent","Array","map","call","c","charCodeAt","toString","slice","join","decodeToken","token","parts","split","decoded","JSON","parse","getTokenExpirationDate","hasOwnProperty","date","Date","setUTCSeconds","exp","isTokenExpired","offsetSeconds","valueOf","getAuthScheme","authScheme","request","Injectable","Inject","args","JwtInterceptor","jwtHelper","document","standardPorts","headerName","allowedDomains","disallowedRoutes","throwNoTokenError","skipWhenExpired","isAllowedDomain","requestUrl","URL","url","location","origin","host","hostName","hostname","port","includes","findIndex","domain","RegExp","test","isDisallowedRoute","_this","requestedUrl","route","parsedRoute","pathname","handleInterception","next","tokenIsExpired","clone","setHeaders","_a","handle","intercept","Promise","from","pipe","mergeMap","asyncToken","Document","decorators","type","DOCUMENT","JwtModule","parentModule","forRoot","options","ngModule","providers","provide","HTTP_INTERCEPTORS","useClass","multi","jwtOptionsProvider","useValue","NgModule","Optional","SkipSelf"],"mappings":"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","sourcesContent":["import { InjectionToken } from '@angular/core';\n\nexport const JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n","import { HttpRequest } from \"@angular/common/http\";\n// tslint:disable:no-bitwise\n\nimport { Injectable, Inject } from \"@angular/core\";\nimport { JWT_OPTIONS } from \"./jwtoptions.token\";\n\n@Injectable()\nexport class JwtHelperService {\n  tokenGetter: () => string;\n\n  constructor(@Inject(JWT_OPTIONS) config = null) {\n    this.tokenGetter = (config && config.tokenGetter) || function () {};\n  }\n\n  public urlBase64Decode(str: string): string {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n      case 0: {\n        break;\n      }\n      case 2: {\n        output += \"==\";\n        break;\n      }\n      case 3: {\n        output += \"=\";\n        break;\n      }\n      default: {\n        throw new Error(\"Illegal base64url string!\");\n      }\n    }\n    return this.b64DecodeUnicode(output);\n  }\n\n  // credits for decoder goes to https://github.com/atk\n  private b64decode(str: string): string {\n    const chars =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    let output = \"\";\n\n    str = String(str).replace(/=+$/, \"\");\n\n    if (str.length % 4 === 1) {\n      throw new Error(\n        \"'atob' failed: The string to be decoded is not correctly encoded.\"\n      );\n    }\n\n    for (\n      // initialize result and counters\n      let bc = 0, bs: any, buffer: any, idx = 0;\n      // get next character\n      (buffer = str.charAt(idx++));\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer &&\n      ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n      // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4)\n        ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n        : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  }\n\n  private b64DecodeUnicode(str: any) {\n    return decodeURIComponent(\n      Array.prototype.map\n        .call(this.b64decode(str), (c: any) => {\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n  }\n\n  public decodeToken<T = any>(token: string = this.tokenGetter()): T {\n    if (!token || token === \"\") {\n      return null;\n    }\n\n    const parts = token.split(\".\");\n\n    if (parts.length !== 3) {\n      throw new Error(\n        \"The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.\"\n      );\n    }\n\n    const decoded = this.urlBase64Decode(parts[1]);\n    if (!decoded) {\n      throw new Error(\"Cannot decode the token.\");\n    }\n\n    return JSON.parse(decoded);\n  }\n\n  public getTokenExpirationDate(\n    token: string = this.tokenGetter()\n  ): Date | null {\n    let decoded: any;\n    decoded = this.decodeToken(token);\n\n    if (!decoded || !decoded.hasOwnProperty(\"exp\")) {\n      return null;\n    }\n\n    const date = new Date(0);\n    date.setUTCSeconds(decoded.exp);\n\n    return date;\n  }\n\n  public isTokenExpired(\n    token: string = this.tokenGetter(),\n    offsetSeconds?: number\n  ): boolean {\n    if (!token || token === \"\") {\n      return true;\n    }\n    const date = this.getTokenExpirationDate(token);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (date === null) {\n      return false;\n    }\n\n    return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n  }\n\n  public getAuthScheme(\n    authScheme: Function | string | undefined,\n    request: HttpRequest<any>\n  ): string {\n    if (typeof authScheme === \"function\") {\n      return authScheme(request);\n    }\n\n    return authScheme;\n  }\n}\n","import { Injectable, Inject } from \"@angular/core\";\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n} from \"@angular/common/http\";\nimport { DOCUMENT } from \"@angular/common\";\nimport { JwtHelperService } from \"./jwthelper.service\";\nimport { JWT_OPTIONS } from \"./jwtoptions.token\";\n\nimport { mergeMap } from \"rxjs/operators\";\nimport { from, Observable } from \"rxjs\";\n\n@Injectable()\nexport class JwtInterceptor implements HttpInterceptor {\n  tokenGetter: (\n    request?: HttpRequest<any>\n  ) => string | null | Promise<string | null>;\n  headerName: string;\n  authScheme: string | ((request?: HttpRequest<any>) => string);\n  allowedDomains: Array<string | RegExp>;\n  disallowedRoutes: Array<string | RegExp>;\n  throwNoTokenError: boolean;\n  skipWhenExpired: boolean;\n  standardPorts: string[] = [\"80\", \"443\"];\n\n  constructor(\n    @Inject(JWT_OPTIONS) config: any,\n    public jwtHelper: JwtHelperService,\n    @Inject(DOCUMENT) private document: Document\n  ) {\n    this.tokenGetter = config.tokenGetter;\n    this.headerName = config.headerName || \"Authorization\";\n    this.authScheme =\n      config.authScheme || config.authScheme === \"\"\n        ? config.authScheme\n        : \"Bearer \";\n    this.allowedDomains = config.allowedDomains || [];\n    this.disallowedRoutes = config.disallowedRoutes || [];\n    this.throwNoTokenError = config.throwNoTokenError || false;\n    this.skipWhenExpired = config.skipWhenExpired;\n  }\n\n  isAllowedDomain(request: HttpRequest<any>): boolean {\n    const requestUrl: URL = new URL(request.url, this.document.location.origin);\n\n    // If the host equals the current window origin,\n    // the domain is allowed by default\n    if (requestUrl.host === this.document.location.host) {\n      return true;\n    }\n\n    // If not the current domain, check the allowed list\n    const hostName = `${requestUrl.hostname}${\n      requestUrl.port && !this.standardPorts.includes(requestUrl.port)\n        ? \":\" + requestUrl.port\n        : \"\"\n    }`;\n\n    return (\n      this.allowedDomains.findIndex((domain) =>\n        typeof domain === \"string\"\n          ? domain === hostName\n          : domain instanceof RegExp\n          ? domain.test(hostName)\n          : false\n      ) > -1\n    );\n  }\n\n  isDisallowedRoute(request: HttpRequest<any>): boolean {\n    const requestedUrl: URL = new URL(\n      request.url,\n      this.document.location.origin\n    );\n\n    return (\n      this.disallowedRoutes.findIndex((route: string | RegExp) => {\n        if (typeof route === \"string\") {\n          const parsedRoute: URL = new URL(\n            route,\n            this.document.location.origin\n          );\n          return (\n            parsedRoute.hostname === requestedUrl.hostname &&\n            parsedRoute.pathname === requestedUrl.pathname\n          );\n        }\n\n        if (route instanceof RegExp) {\n          return route.test(request.url);\n        }\n\n        return false;\n      }) > -1\n    );\n  }\n\n  handleInterception(\n    token: string | null,\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ) {\n    const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n    let tokenIsExpired = false;\n\n    if (!token && this.throwNoTokenError) {\n      throw new Error(\"Could not get token from tokenGetter function.\");\n    }\n\n    if (this.skipWhenExpired) {\n      tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n    }\n\n    if (token && tokenIsExpired && this.skipWhenExpired) {\n      request = request.clone();\n    } else if (token) {\n      request = request.clone({\n        setHeaders: {\n          [this.headerName]: `${authScheme}${token}`,\n        },\n      });\n    }\n    return next.handle(request);\n  }\n\n  intercept(\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n      return next.handle(request);\n    }\n    const token = this.tokenGetter(request);\n\n    if (token instanceof Promise) {\n      return from(token).pipe(\n        mergeMap((asyncToken: string | null) => {\n          return this.handleInterception(asyncToken, request, next);\n        })\n      );\n    } else {\n      return this.handleInterception(token, request, next);\n    }\n  }\n}\n","import {\n  NgModule,\n  ModuleWithProviders,\n  Optional,\n  SkipSelf,\n  Provider,\n} from \"@angular/core\";\nimport { HttpRequest, HTTP_INTERCEPTORS } from \"@angular/common/http\";\nimport { JwtInterceptor } from \"./jwt.interceptor\";\nimport { JWT_OPTIONS } from \"./jwtoptions.token\";\nimport { JwtHelperService } from \"./jwthelper.service\";\n\nexport interface JwtConfig {\n  tokenGetter?: (\n    request?: HttpRequest<any>\n  ) => string | null | Promise<string | null>;\n  headerName?: string;\n  authScheme?: string | ((request?: HttpRequest<any>) => string);\n  allowedDomains?: Array<string | RegExp>;\n  disallowedRoutes?: Array<string | RegExp>;\n  throwNoTokenError?: boolean;\n  skipWhenExpired?: boolean;\n}\n\nexport interface JwtModuleOptions {\n  jwtOptionsProvider?: Provider;\n  config?: JwtConfig;\n}\n\n@NgModule()\nexport class JwtModule {\n  constructor(@Optional() @SkipSelf() parentModule: JwtModule) {\n    if (parentModule) {\n      throw new Error(\n        \"JwtModule is already loaded. It should only be imported in your application's main module.\"\n      );\n    }\n  }\n  static forRoot(options: JwtModuleOptions): ModuleWithProviders<JwtModule> {\n    return {\n      ngModule: JwtModule,\n      providers: [\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: JwtInterceptor,\n          multi: true,\n        },\n        options.jwtOptionsProvider || {\n          provide: JWT_OPTIONS,\n          useValue: options.config,\n        },\n        JwtHelperService,\n      ],\n    };\n  }\n}\n"]}